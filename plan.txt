StudentTextEditor:
	need to store rows and cols: list<string>

StudentUndo:
	need to store actions, characters
	store in a stack<node>
	where node:
		action
		string

StudentSpellCheck
	place words in trie
	each node of trie has node structure of data, and children pointers


previous trie legacy:
    /*
    class Trie
    {
    public:
        bool isEnd;
        Trie* character[CHARS];

        // Constructor
        Trie()
        {
            this->isEnd = false;

            for (int i = 0; i < CHARS; i++) {
                this->character[i] = nullptr;
            }
        }

        void insert(std::string key)
        {
            // start from the root node
            Trie* curr = this;
            for (int i = 0; i < key.length(); i++)
            {
                // create a new node if the path doesn't exist
                if (curr->character[key[i]] == nullptr) {
                    curr->character[key[i]] = new Trie();
                }

                // go to the next node
                curr = curr->character[key[i]];
            }

            // mark the current node as a leaf
            curr->isEnd = true;
        }
        bool hasChildren(Trie const* curr)
        {
            for (int i = 0; i < CHARS; i++)
            {
                if (curr->character[i]) {
                    return true;    // child found
                }
            }
            return false;
        }
        bool deletion(Trie*& curr, std::string key)
        {
            // return if Trie is empty
            if (curr == nullptr) {
                return false;
            }

            // if the end of the key is not reached
            if (key.length())
            {
                // recur for the node corresponding to the next character in the key
                // and if it returns true, delete the current node (if it is non-leaf)

                if (curr != nullptr &&
                    curr->character[key[0]] != nullptr &&
                    deletion(curr->character[key[0]], key.substr(1)) &&
                    curr->isEnd == false)
                {
                    if (!hasChildren(curr))
                    {
                        delete curr;
                        curr = nullptr;
                        return true;
                    }
                    else {
                        return false;
                    }
                }
            }

            // if the end of the key is reached
            if (key.length() == 0 && curr->isEnd)
            {
                // if the current node is a leaf node and doesn't have any children
                if (!hasChildren(curr))
                {
                    // delete the current node
                    delete curr;
                    curr = nullptr;

                    // delete the non-leaf parent nodes
                    return true;
                }

                // if the current node is a leaf node and has children
                else {
                    // mark the current node as a non-leaf node (DON'T DELETE IT)
                    curr->isEnd = false;

                    // don't delete its parent nodes
                    return false;
                }
            }

            return false;
        }
        bool search(std::string key)
        {
            // return false if Trie is empty
            if (this == nullptr) {
                return false;
            }

            Trie* curr = this;
            for (int i = 0; i < key.length(); i++)
            {
                // go to the next node
                curr = curr->character[key[i]];

                // if the string is invalid (reached end of a path in the Trie)
                if (curr == nullptr) {
                    return false;
                }
            }

            // return true if the current node is a leaf and the
            // end of the string is reached
            return curr->isEnd;
        }
       
    };
    Trie* m_root;

    */